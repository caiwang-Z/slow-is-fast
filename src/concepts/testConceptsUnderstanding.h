#include <fstream>
#include <iostream>
#include <map>
#include <vector>
#include "utility.h"

using UtilityNameSpace::myLog;
using UtilityNameSpace::splitLine;
using UtilityNameSpace::Splitter;

// TODO std::flush

namespace TestStopUsingSTDEndl {

/*
*
std::endl——Insert newline and flush
std::ends——Insert null character
std::flush——Flush stream buffer
*
1.What is Buffer?
Buffer is also known as cache, which is a part of memory space.That is to say,
a certain amount of storage space is reserved in the memory space which is used
to buffer input or output data, and this reserved space is called buffer.Buffers
are categorized into input buffers and output buffers depending on whether they
correspond to input or output devices.

2. Why do we need to introduce buffers?
For example, we take information from the disk, we first read out the data in
the buffer, the computer and then directly from the buffer to take the data,
such as buffer data to take the end of the disk and then go to read, so you can
reduce the number of times the disk read and write, coupled with the computer's
operation of the buffer is much faster than the operation of the disk, it is the
application of the buffer can greatly increase the speed of computer
operations.Another example, we use the printer to print documents, due to the
printer's printing speed is relatively slow, we first output the document to the
printer's corresponding buffer, the printer and then gradually print their own,
then our CPU can deal with other things. Now you basically understand it, the
buffer is a piece of memory, it is used between the input and output devices and
the CPU, used to cache data.It allows low-speed I/O devices and high-speed CPU
to work in harmony, avoiding low-speed I/O devices from occupying the CPU and
freeing the CPU to work efficiently.

3.Buffer Flush
Flushing a buffer is the process of taking the data in the buffer, performing
real I/O, and then emptying the buffer.As you can see from the example above,
the following situations trigger a buffer flush:
a. when the buffer is full;
b. at the end of the program;
c. by executing the flush statement;
d. by closing the file, i.e., by executing the close statement;
e. by executing the endl statement.

*/

void test() {
  std::ofstream outFile("test.txt");
  for (int n = 0; n < 4096; ++n) {
    outFile << 'A';
  }  // the data is still in buffer, not in the file. No I/O process.

  std::ofstream outFile1("test1.txt");
  for (int n = 0; n < 4096; ++n) {
    outFile1 << 'A';
  }
  outFile1 << std::endl;  // data in buffer has been writen into file.

  std::ofstream outFile2("test2.txt");
  for (int n = 0; n < 4096; ++n) {
    outFile2 << 'A';
  }
  outFile2.close();  // data in buffer has been writen into file.

  {
    std::ofstream outFile3("test3.txt");
    for (int n = 0; n < 4096; ++n) {
      outFile3 << 'A';
    }
    int a = 1;  // data in buffer has been writen into file.
  }

  int a = 1;
}

}  // namespace TestStopUsingSTDEndl

namespace TestNameDemangling {
/*
C++ Name Demangling is the process of restoring the "mangled" names of symbols
(e.g., function names, variable names, etc.) that are internally processed by
the compiler in C++ code to their original human-readable names.Since C++
supports function overloading and other advanced features, the compiler modifies
the names of symbols when generating the object code to uniquely identify each
symbol, a process called "name mangling".

However, such modified symbol names are very difficult for humans to understand and debug.The technique of "name
demangling" is needed to restore these symbols to their original readable names.The exact methods of mangling and
demangling may vary between platforms and compilers.Some commonly used tools and libraries, such as the c++filt tool
provided by GCC, can be used to perform this process.

Common Uses:
* Debugging: Debuggers and analysis tools utilize demangling to convert symbolic names into human-readable
    form to help developers locate problems.
* Logging and Bug Reporting: The use of demangling can provide more meaningful
information in the stack trace generated when a program crashes.
* Performance analysis: Performance analysis tools
demangling the collected symbol information so that developers can analyze performance bottlenecks.

Summary
C++ Name Demangling is the process of reducing the internal names generated by the compiler to handle C++ symbols to
their original, readable names.This is important for debugging, log analysis, and performance optimization.

*/

}  // namespace TestNameDemangling

namespace TestClangFormat {
/*
1. file name must be .clang-format. And put in the root directory of the project
2. enable clang format support in visual studio
3. Ctrl + K and Ctrl + D, apply code formating  for current file
*/

}

namespace TestFoldExpression {
namespace TestMonadicLeftFolding {
// Monadic left folding
// (... operation pack)

template <typename... Args>
auto sum(Args... args) {
  return (... + args);  // Sum the argument packet args from left to right.
}
}  // namespace TestMonadicLeftFolding

namespace TestMondadicRightFolding {
// Monadic right folding
// (pack operation ...)

template <typename... Args>
auto sum(Args... args) {
  return (args + ...);  // sum the argument packet args from right to left.
}

}  // namespace TestMondadicRightFolding

namespace TestBinaryLeftFolding {
// Binary left folding
// (initValue operation ... operation pack)
template <typename... Args>
auto sum(Args... args) {
  return (10 + ... + args);
}

}  // namespace TestBinaryLeftFolding

namespace TestBinaryRightFolding {
// Binary right folding:
// (pack operation ... operation initValue)

template <typename... Args>
auto sum(Args... args) {
  return (args + ... + 20);
}

}  // namespace TestBinaryRightFolding

void test() {
  const auto res1 = TestMonadicLeftFolding::sum(1, 2, 3, 4, 5);
  const auto res2 = TestMondadicRightFolding::sum(1, 2, 3, 4, 5);
  const auto res3 = TestBinaryLeftFolding::sum(1, 2, 3, 4, 5);
  const auto res4 = TestBinaryRightFolding::sum(1, 2, 3, 4, 5);
  int        a    = 1;
}

}  // namespace TestFoldExpression

namespace TestVariadicExpansionWrapUp {
/*
In C++, variadic templates allow a function to take an arbitrary number of arguments.Varadic expansion is the process of
expanding these parameters and processing them.Varadic Expansion Wrap-Up usually involves expanding the varadic template
parameters and performing some kind of processing.
*/
template <typename T>
void print(T t) {
  std::cout << t << "\n";
}

template <typename T, typename... Args>
void print(T t, Args... args) {
  std::cout << t << "\n";  // comment this line: try world; No comment: try 1 2.5 Hello world
  print(args...);
}

/*
In some cases, you may want to process all the variables in a single operation, rather than one by one.In this case, you
can use the "wrapping" technique of variant expansion, such as initializing lists or collapsing expressions (a feature
introduced in C++17) to handle all the arguments at once.

*/
template <typename... Args>
void print_all(Args... args) {
  //((std::cout << args << std::endl), ...);
  //(..., (std::cout << args << "\n") );
  ((std::cout << args << "\n"), ...);
}

void test() {
  print("try");
  print(1, 2.5, "Hello", "world");
  print_all("new", "world", 4, 8, 90);
}

}  // namespace TestVariadicExpansionWrapUp

namespace TestAssignmentInIfExpression {
/*
The assignment operation itself is an expression, and it results in the left operand of the assigned value.

This behavior allows assignment operations to be used as part of conditional expressions.
*/
void test() {
  const std::map<std::string, int> myMap{{"one", 1}, {"two", 2}};
  if (auto it = myMap.find("two"); it != myMap.end()) {
    std::cout << "Found element\n";

  } else {
    std::cout << "Finding element failed\n";
  }
}
}  // namespace TestAssignmentInIfExpression

namespace TestIfAndSwitchInitStatements {
/*
C++17's if and switch Init Statements
This allows you to define and initialize variables in the same scope and then immediately use them for conditional
judgments.

This approach avoids the need to define value variables outside of an if statement, and makes the code more compact and
clearer
*/
void testIfInitStatement() {
  const std::vector<int> vec{1, 2, 3, 4};
  if (auto itr = std::find(vec.cbegin(), vec.cend(), 3); itr != vec.end()) {
    std::cout << "Found value: " << *itr << "\n";  // 3
  }  // cons: itr is not visible outside or inside this function. I do not allow it.
}

void testSwitchInitStatement() {
  const std::string var{"example"};
  switch (auto len = var.length(); len) {
    case 0:
      // do something
      break;
    case 1:
      // do something
      break;
    case 7:
      std::cout << "length is: " << len << std::endl;  // 7
      break;
  }
}

void test() {
  testIfInitStatement();
  testSwitchInitStatement();
}

}  // namespace TestIfAndSwitchInitStatements

namespace TestNestedNamespace {
/*
Before C++17, to define multiple nested namespaces, you had to define them layer by layer:
*/
namespace A {
namespace B {
namespace C {
void foo() {}
}  // namespace C
}  // namespace B
}  // namespace A

/*
C++17 introduced the nested namespace syntax, which allows you to define multiple nested namespaces on a single line:
This makes namespace definitions more concise and clear, especially if the hierarchy is deeper

*/

namespace E::F::G {
void foo() {}
}  // namespace E::F::G

void test() {
  A::B::C::foo();
  E::F::G::foo();
}

}  // namespace TestNestedNamespace

namespace TestHasInclude {
/*
C++17 introduces a preprocessor directive, __has_include, which allows checking for the existence of a header file
during compilation.This is useful for conditional compilation and cross-platform programming, where different code paths
can be chosen depending on the availability of header files.

Example 1:

#if __has_include(<header>)
    // Code if header is available
#else
    // Code if header is not available
#endif

Example 2:
#include <iostream>

#if __has_include(<filesystem>)
    #include <filesystem>
    namespace fs = std::filesystem;
#elif __has_include(<experimental/filesystem>)
    #include <experimental/filesystem>
    namespace fs = std::experimental::filesystem;
#else
    #error "No filesystem support"
#endif

int main() {
    fs::path p = "/path/to/somewhere";
    std::cout << "Path: " << p << std::endl;
    return 0;
}

Summary:
C++17's __has_include is a powerful tool that allows programmers to check the availability of header files
during compilation, leading to conditional compilation and better cross-platform compatibility.By using __has_include
flexibly, it is possible to write more robust and adaptable code.

*/

}

namespace TestStructuredBindings {
/*
Summary
C++17's structured bindings provide a concise and intuitive way to deconstruct complex data structures, making
code easier to read and maintain.By using structured bindings wisely, you can improve code readability and development
efficiency in many scenarios.
*/

void testDeconstructingTuples() {
  std::tuple<int, std::string, float> tp{10, "lee", 1.89f};
  auto [age, name, height] = tp;
  std::cout << "Name: " << name << ", age: " << age << ", height: " << height << "\n";
}

namespace testDeconstructingStruct {
struct Person {
  std::string name;
  int         age;
  float       height;
};
void test() {
  Person ps{"Jack", 63, 1.90f};
  auto [name, age, height] = ps;
  std::cout << "Name: " << name << ", age: " << age << ", height: " << height << "\n";
}

}  // namespace testDeconstructingStruct

void testDeconstructingArray() {
  int arr[]{11, 22, 33};
  auto [a, b, c] = arr;
  std::cout << "a: " << a << ", b: " << b << ", c: " << c << "\n";
}

namespace TestDeconstructingFuncReturnValues {
std::pair<int, std::string> foo() {
  return {99, "david"};
}

void test() {
  auto [age, name] = foo();
  std::cout << "Name: " << name << ", age: " << age << "\n";
}
}  // namespace TestDeconstructingFuncReturnValues

void testDeconstructingSTDMap() {
  std::map<int, std::string> map{{1, "jack"}, {2, "manda"}, {45, "kk"}};
  for (const auto& [id, name] : map) {
    std::cout << "Key: " << id << ", name: " << name << "\n";
  }
}

void test() {
  testDeconstructingTuples();
  testDeconstructingStruct::test();
  testDeconstructingArray();
  TestDeconstructingFuncReturnValues::test();
  testDeconstructingSTDMap();
}

}  // namespace TestStructuredBindings

namespace TestAggregateInitialization {
/*
C++ 17 Definition of an Aggregate:
A type is an aggregate if it satisfies all of the following conditions: it is an array type
or class (usually a structure) and has no user-supplied constructor.It has no private or protected non-static data
members.It has no base classes.It has no virtual member functions.

Initialization Syntax:
An aggregation can be
initialized using an initialization list surrounded by curly braces.The following are some examples to illustrate
aggregate initialization:
*/
namespace TestInitlizationStruct {
struct Point {
  int x;
  int y;
};

void test() {
  Point p1{1, 2};
  Point p2{3, 4};
}
}  // namespace TestInitlizationStruct

namespace TestNestedAggregation {
struct Rectange {
  TestInitlizationStruct::Point topLeft;
  TestInitlizationStruct::Point bottomRight;
};

void test() {
  Rectange rect{{1, 2}, {3, 4}};
}
}  // namespace TestNestedAggregation

namespace TestAggregationWithDefaultMemberInitializer {
struct Point {
  float x = 1.1f;
  float y = 2.2f;
};

void test() {
  Point p1{8.9, 4.5};
  Point p2;
}

}  // namespace TestAggregationWithDefaultMemberInitializer

}  // namespace TestAggregateInitialization

namespace TestFloatingLiteralsDefinition {
/*
Summary The f or F suffix is used to specify a floating-point literal as a float.By default, float literals are treated
as double.Using the f suffix saves memory, improves performance, and avoids unnecessary implicit conversions.
*/

void test() {
  float f1 = 3.14;   // Implicitly a double, then converted to float
  float f2 = 3.14f;  // Explicitly a float

  double      d1  = 3.14;   // Default to double
  long double ld1 = 3.14L;  // Explicitly a long double

  std::cout << "size of f1: " << sizeof(f1) << " bytes.\n";    // 4
  std::cout << "size of f2: " << sizeof(f2) << " bytes.\n";    // 4
  std::cout << "size of d1: " << sizeof(d1) << " bytes.\n";    // 8
  std::cout << "size of ld1: " << sizeof(ld1) << " bytes.\n";  // 16 (depends on hardware architecture, platfform, win10 msvc 8 bytes)
}

}  // namespace TestFloatingLiteralsDefinition

void test() {
  TestFloatingLiteralsDefinition::test();
  //TestStructuredBindings::test();
  // TestIfAndSwitchInitStatements::test();
  //  TestStopUsingSTDEndl::test();
  //  TestVariadicExpansionWrapUp::test();
  //  TestFoldExpression::test();
}